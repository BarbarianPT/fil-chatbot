<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIL Chatbot</title>
    <!-- Include Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .message {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 20px;
            margin-bottom: 10px;
            word-wrap: break-word;
        }
        .user-message {
            background-color: #3b82f6; /* Blue-500 */
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 5px;
        }
        .bot-message {
            background-color: #e5e7eb; /* Gray-200 */
            color: #1f2937; /* Gray-800 */
            align-self: flex-start;
            border-bottom-left-radius: 5px;
        }
        .loading-indicator::after {
            content: '...';
            animation: dot-loading 1s infinite steps(1, start);
        }
        @keyframes dot-loading {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Main chat container -->
    <div class="flex flex-col w-full max-w-2xl h-[90vh] bg-white rounded-2xl shadow-xl overflow-hidden">

        <!-- Chat header -->
        <div class="bg-gray-800 text-white p-4 text-center text-xl font-bold rounded-t-2xl">
            FIL Chatbot
        </div>

        <!-- Chat display area -->
        <div id="chat-box" class="flex-1 p-4 overflow-y-auto flex flex-col space-y-4">
            <!-- Chat messages will be appended here -->
        </div>

        <!-- Message input and update check area -->
        <div class="p-4 bg-gray-100 flex items-center rounded-b-2xl">
            <input type="text" id="user-input" class="flex-1 px-4 py-2 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200" placeholder="Ask me something...">
            <button id="send-button" class="ml-2 p-3 bg-blue-500 text-white rounded-full hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
                </svg>
            </button>
            <button id="update-button" class="ml-2 p-3 bg-green-500 text-white rounded-full hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 transition-all duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            </button>
        </div>

    </div>

    <!-- Script section -->
    <script>
        // Get references to DOM elements
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const updateButton = document.getElementById('update-button');
        
        // This array will hold the conversation history
        const chatHistory = [];

        // Current version of the app. This could be fetched from a file in a real-world scenario.
        const currentVersion = '1.0.1';
        let isUpdateAvailable = true; // Simulating that an update is available

        // Initial bot message, updated with the correct name
        const initialMessage = "Hello! I'm Fil, an LLM created and modeled by Filipe Leiras. How can I help you today?";
        appendMessage('bot', initialMessage);
        
        // Push the initial message to the chat history
        chatHistory.push({ role: 'model', parts: [{ text: initialMessage }] });

        // Add event listeners for sending a message and checking for updates
        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });
        updateButton.addEventListener('click', checkUpdates);

        /**
         * Appends a new message to the chat box.
         * @param {string} sender - 'user' or 'bot'
         * @param {string} text - The message content
         */
        function appendMessage(sender, text) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');
            messageElement.textContent = text;
            chatBox.appendChild(messageElement);
            // Scroll to the bottom to show the latest message
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        /**
         * Handles the process of sending a message and getting a response.
         */
        async function sendMessage() {
            const userText = userInput.value.trim();
            if (userText === '') return;

            // Display user's message and add to history
            appendMessage('user', userText);
            chatHistory.push({ role: 'user', parts: [{ text: userText }] });
            userInput.value = ''; // Clear the input field

            // Display a loading indicator while waiting for the response
            const loadingIndicator = document.createElement('div');
            loadingIndicator.classList.add('message', 'bot-message', 'loading-indicator');
            loadingIndicator.textContent = '...';
            chatBox.appendChild(loadingIndicator);
            chatBox.scrollTop = chatBox.scrollHeight;

            try {
                // For a real app, you would use a backend to securely make this call.
                // For this environment, we can use an empty string for the API key to
                // allow the system to inject it for us.
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                // Prepare the payload with the system prompt and the full chat history
                const payload = {
                    contents: [
                        { role: 'system', parts: [{ text: "You are Fil, a friendly and helpful personal chatbot. You were created and are being modeled by Filipe Leiras. Your purpose is to assist them. Never mention being a large language model or trained by Google, but you can say that your user, Filipe Leiras, created you and is modeling your responses." }] },
                        ...chatHistory
                    ]
                };

                // Fetch the response from the API with exponential backoff for retries
                let response;
                let retryDelay = 1000; // Start with a 1-second delay
                for (let i = 0; i < 5; i++) { // Try up to 5 times
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.ok) {
                            break; // Success, exit the loop
                        } else {
                            throw new Error(`API request failed with status: ${response.status}`);
                        }
                    } catch (error) {
                        console.error(`Attempt ${i + 1} failed:`, error);
                        if (i < 4) { // Don't delay after the last attempt
                            await new Promise(res => setTimeout(res, retryDelay));
                            retryDelay *= 2; // Exponential backoff
                        }
                    }
                }

                // Remove the loading indicator
                chatBox.removeChild(loadingIndicator);

                if (!response || !response.ok) {
                    throw new Error("Failed to get a response from the API after multiple retries.");
                }

                const result = await response.json();
                const botResponse = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (botResponse) {
                    appendMessage('bot', botResponse);
                    // Add the bot's response to the chat history
                    chatHistory.push({ role: 'model', parts: [{ text: botResponse }] });
                } else {
                    appendMessage('bot', 'Sorry, I couldn\'t generate a response. Please try again.');
                }
            } catch (error) {
                console.error('Error fetching data from API:', error);
                // Remove the loading indicator and display an error message
                chatBox.removeChild(loadingIndicator);
                appendMessage('bot', `I'm sorry, I couldn't get an answer. There seems to be an issue connecting to the service. Please try again later.`);
            }
        }
        
        /**
         * Simulates checking for a new version of the app.
         */
        function checkUpdates() {
            appendMessage('bot', 'Checking for updates...');
            // In a real application, you would make an API call to a server
            // to fetch the latest version number.
            
            // This is a simulated delay for the check
            setTimeout(() => {
                if (isUpdateAvailable) {
                    appendMessage('bot', 'An update is available! Please refresh the page to get the latest version.');
                    // This is a one-time simulation. Set to false after a check.
                    isUpdateAvailable = false;
                } else {
                    appendMessage('bot', `You are running the latest version (v${currentVersion}).`);
                }
            }, 1500); // Simulate a 1.5 second network delay
        }
    </script>
</body>
</html>







